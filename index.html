<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>é ˜ä¸»äº”å­æ£‹ V13.3 (çŸ­ç¢¼é€£ç·šç‰ˆ)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- æ²¿ç”¨ V13.3 çš„è¦–è¦ºé¢¨æ ¼ --- */
        :root {
            --bg: #efe3d0;
            --grid: #5d4037;
            --cell: #d2a679;
            --p1: #2c3e50;
            --p2: #c0392b;
            --panel: #3d2b24;
            --accent: #ffeb3b;
        }

        * {
            touch-action: manipulation;
            box-sizing: border-box;
            -webkit-user-select: none;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }

        body {
            background: var(--bg);
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            align-items: center;
        }

        /* å…¥å£å¤§å»³ */
        #lobby-overlay {
            position: fixed;
            inset: 0;
            background: var(--panel);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .lobby-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .mode-btn {
            background: var(--accent);
            color: var(--panel);
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 0;
            width: 100%;
        }

        #pvp-setup {
            display: none;
            margin-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
        }

        .id-display {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            color: var(--accent);
            font-size: 24px;
            /* åŠ å¤§å­—é«” */
            font-weight: bold;
            letter-spacing: 2px;
            margin: 10px 0;
            cursor: pointer;
            border: 2px dashed #444;
        }

        input {
            padding: 12px;
            border-radius: 8px;
            border: none;
            width: 100%;
            text-align: center;
            margin-bottom: 10px;
            font-size: 18px;
            text-transform: uppercase;
            /* å¼·åˆ¶å¤§å¯« */
        }

        .hint-text {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }

        /* é ‚éƒ¨å›åˆç‹€æ…‹ */
        #turn-indicator {
            width: 100%;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 900;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
            flex-shrink: 0;
        }

        .turn-my {
            background: var(--p1);
        }

        .turn-opp {
            background: var(--p2);
        }

        .turn-wait {
            animation: blink 1.5s infinite;
            opacity: 0.8;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        /* æ ¸å¿ƒå®¹å™¨ */
        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            width: 100%;
            padding-top: 15px;
        }

        /* æ‰‹ç‰Œé¡¯ç¤ºå€ */
        #card-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .hand-label {
            font-size: 26px;
            color: var(--grid);
            font-weight: 900;
            text-shadow: 1px 1px 0px #fff;
        }

        .card-preview {
            width: 100px;
            height: 135px;
            background: #fff;
            border: 5px solid var(--grid);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        /* æ£‹ç›¤ */
        #game-area {
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 5px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            background: var(--grid);
            gap: 1px;
            border: 5px solid var(--grid);
            width: min(95vw, 50dvh);
            aspect-ratio: 1 / 1;
            transition: 0.3s;
        }

        .my-turn-glow {
            box-shadow: 0 0 30px var(--accent);
        }

        .cell {
            background: var(--cell);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* é€™è£¡çš„å‘½åå°æ‡‰ V13.3 çš„é‚è¼¯: player=è—æ–¹, ai=ç´…æ–¹ */
        .piece.player {
            background: var(--p1);
            color: white;
        }

        .piece.ai {
            background: var(--p2);
            color: white;
        }

        .piece.lord {
            border-radius: 4px;
        }

        .piece.knight,
        .piece.mage {
            border-radius: 50%;
        }

        .piece.converted {
            border: 3px dashed var(--accent);
        }

        .piece.last-move {
            border: 3px solid white;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.15);
            }
        }

        .dir-hint {
            font-size: 12px;
            color: var(--accent);
            font-weight: bold;
        }

        /* å‹è² å½ˆçª— */
        #win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #win-overlay.show {
            display: flex;
        }

        .win-box {
            background: var(--panel);
            padding: 50px 30px;
            border-radius: 30px;
            border: 5px solid var(--accent);
            text-align: center;
        }

        .win-title {
            font-size: 36px;
            font-weight: 900;
            color: white;
            margin-bottom: 25px;
        }

        .win-btn {
            padding: 15px 40px;
            background: var(--accent);
            color: var(--panel);
            border: none;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }

        #msg-pop {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            opacity: 0;
            z-index: 1500;
            transition: 0.3s;
            font-size: 18px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="win-overlay">
        <div class="win-box">
            <div id="win-text" class="win-title">ğŸ† ç²å¾—å‹åˆ©</div>
            <button class="win-btn" onclick="location.reload()">å†ç©ä¸€å±€</button>
        </div>
    </div>

    <div id="lobby-overlay">
        <div class="lobby-card">
            <h1 style="color:var(--accent); margin-bottom: 20px;">é ˜ä¸»äº”å­æ£‹ V13.3</h1>
            <button class="mode-btn" onclick="showPVP()">âš”ï¸ å¥½å‹é€£ç·šå°æˆ°</button>
            <button class="mode-btn" style="background:#ddd" onclick="startAI()">ğŸ¤– æŒ‘æˆ° AI</button>

            <div id="pvp-setup">
                <div class="hint-text">ä½ çš„æˆ¿é–“ä»£ç¢¼ (é»æ“Šè¤‡è£½):</div>
                <div class="id-display" id="my-id" onclick="copyID()">ç”Ÿæˆä¸­...</div>

                <div class="hint-text" style="margin-top:15px">è¼¸å…¥å¥½å‹ä»£ç¢¼åŠ å…¥:</div>
                <input type="text" id="peer-id-input" placeholder="6ä½æ•¸ä»£ç¢¼" maxlength="6">

                <button class="mode-btn" style="background:#fff; border:2px solid var(--accent)"
                    onclick="connectToFriend()">åŠ å…¥æˆ¿é–“</button>
                <div id="status-msg" style="color:#ff6b6b; font-size:14px; margin-top:5px;"></div>
            </div>
        </div>
    </div>

    <div id="turn-indicator" class="turn-my">æº–å‚™ä¸­...</div>

    <div id="main-container">
        <div id="card-zone">
            <div class="hand-label">ç›®å‰æŒæœ‰æ‰‹ç‰Œ</div>
            <div class="card-preview" id="game-card">
                <div id="res-icon" style="font-size:55px">ğŸ°</div>
                <div id="res-dir" style="font-size:22px; color:red; font-weight:bold; margin-top:5px;"></div>
            </div>
        </div>

        <div id="game-area">
            <div id="board"></div>
        </div>
    </div>

    <div id="msg-pop"></div>

    <script>
        // --- è¨­å®šèˆ‡ç‹€æ…‹ ---
        const SIZE = 10;
        let peer, conn, myRole = 'PLAYER', isAI = false;
        // PLAYER = è—æ–¹(å…ˆæ‰‹), AI = ç´…æ–¹(å¾Œæ‰‹) -> é€™åœ¨ V13.3 é‚è¼¯æ˜¯å›ºå®šçš„
        let board = [], turn = 'PLAYER', hand = 'LORD', handDir = null;
        let isOver = false, isProcessing = false;
        let lastPos = null;

        const PIECE_DATA = { LORD: { i: 'ğŸ°', class: 'lord' }, KNIGHT: { i: 'ğŸ', class: 'knight' }, MAGE: { i: 'ğŸ§™', class: 'mage' } };
        const DIRS = [{ dr: -1, dc: 0, icon: 'â–²' }, { dr: 1, dc: 0, icon: 'â–¼' }, { dr: 0, dc: -1, icon: 'â—€' }, { dr: 0, dc: 1, icon: 'â–¶' }];

        // --- é€£ç·šé‚è¼¯ (æ”¹ç”¨çŸ­ç¢¼) ---
        function generateShortId()
        {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showPVP()
        {
            document.getElementById('pvp-setup').style.display = 'block';
            if (!peer)
            {
                initPeer();
            }
        }

        function initPeer()
        {
            if (peer) return;
            const shortId = generateShortId();

            // ä½¿ç”¨æ›´ç©©å®šçš„é…ç½®
            peer = new Peer(shortId, {
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                },
                debug: 2 // é–‹å•Ÿé™¤éŒ¯è¨Šæ¯ï¼ˆå¯åœ¨ console çœ‹åˆ°è©³ç´°è³‡è¨Šï¼‰
            });

            peer.on('open', id =>
            {
                document.getElementById('my-id').innerText = id;
                console.log('Peer ID:', id);
            });

            peer.on('error', (err) =>
            {
                console.error('Peer error:', err);
                if (err.type === 'unavailable-id')
                {
                    // æ¥µå°æ©Ÿç‡æ’è™Ÿï¼Œé‡æ–°æ•´ç†
                    location.reload();
                } else if (err.type === 'network' || err.type === 'server-error')
                {
                    document.getElementById('status-msg').innerText = "ä¼ºæœå™¨é€£ç·šå¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†";
                } else
                {
                    document.getElementById('status-msg').innerText = "é€£ç·šéŒ¯èª¤: " + err.type;
                }
            });

            peer.on('disconnected', () =>
            {
                console.log('Peer disconnected, attempting reconnect...');
                peer.reconnect();
            });

            peer.on('connection', c =>
            {
                console.log('Incoming connection from:', c.peer);
                conn = c;
                // è¢«é€£ç·šè€…ç•¶ä½œ PLAYER (è—æ–¹/å…ˆæ‰‹)
                myRole = 'PLAYER';

                // å…ˆè¨­ç½®é€£ç·šç›£è½ï¼Œå†å•Ÿå‹•éŠæˆ²
                c.on('open', () =>
                {
                    console.log('Connection opened');
                    setupConn();
                    startGame();
                });
            });
        }

        function connectToFriend()
        {
            const tid = document.getElementById('peer-id-input').value.trim().toUpperCase();
            if (tid.length !== 6)
            {
                document.getElementById('status-msg').innerText = "è«‹è¼¸å…¥æ­£ç¢ºçš„ 6 ä½ä»£ç¢¼";
                return;
            }

            // ç¢ºä¿ peer å·²åˆå§‹åŒ–
            if (!peer)
            {
                document.getElementById('status-msg').innerText = "åˆå§‹åŒ–ä¸­ï¼Œè«‹ç¨å€™...";
                initPeer();
                // ç­‰å¾… peer åˆå§‹åŒ–å®Œæˆå¾Œå†é€£ç·š
                const checkPeer = setInterval(() =>
                {
                    if (peer && peer.id)
                    {
                        clearInterval(checkPeer);
                        doConnect(tid);
                    }
                }, 100);
                return;
            }

            doConnect(tid);
        }

        function doConnect(tid)
        {
            document.getElementById('status-msg').innerText = "é€£ç·šä¸­...";
            console.log('Attempting to connect to:', tid);

            conn = peer.connect(tid, {
                reliable: true
            });

            // ä¸»å‹•é€£ç·šè€…ç•¶ä½œ AI (ç´…æ–¹/å¾Œæ‰‹ï¼Œåªæ˜¯ç”¨è®Šæ•¸ AI ä»£è¡¨ P2)
            myRole = 'AI';

            conn.on('open', () =>
            {
                console.log('Connection established');
                document.getElementById('status-msg').innerText = "é€£ç·šæˆåŠŸï¼";
                setupConn();
                startGame();
            });

            conn.on('error', (err) =>
            {
                console.error('Connection error:', err);
                document.getElementById('status-msg').innerText = "é€£ç·šå¤±æ•—: " + err.type;
            });

            setTimeout(() =>
            {
                if (!conn || !conn.open)
                {
                    console.error('Connection timeout');
                    document.getElementById('status-msg').innerText = "æ‰¾ä¸åˆ°æˆ¿é–“æˆ–é€£ç·šé€¾æ™‚ï¼Œè«‹ç¢ºèªä»£ç¢¼æ­£ç¢º";
                }
            }, 8000); // å»¶é•·è‡³ 8 ç§’
        }

        function setupConn()
        {
            conn.on('data', data =>
            {
                console.log('Received data:', data);
                if (data.type === 'SYNC_CARD') { hand = data.hand; handDir = data.handDir; updateCardUI(); }
                if (data.type === 'MOVE')
                {
                    // æ¥æ”¶å°æ‰‹ç§»å‹•ï¼šå¦‚æœæˆ‘æ˜¯ PLAYERï¼Œå°æ‰‹å°±æ˜¯ AIï¼›åä¹‹äº¦ç„¶
                    const oppRole = (myRole === 'PLAYER' ? 'AI' : 'PLAYER');
                    executeMove(data.r, data.c, oppRole, data.hand, data.handDir);
                }
            });
            conn.on('close', () => 
            {
                console.log('Connection closed');
                alert("å°æ–¹å·²é›¢é–‹");
                location.reload();
            });
            conn.on('error', (err) =>
            {
                console.error('Connection error:', err);
            });
        }

        // --- éŠæˆ²é‚è¼¯ (V13.3 åŸç‰ˆ) ---
        function startAI() { isAI = true; myRole = 'PLAYER'; startGame(); }

        function startGame()
        {
            document.getElementById('lobby-overlay').style.display = 'none';
            initBoard();
            updateTurnUI();
            prepareTurn();
        }

        function initBoard()
        {
            const b = document.getElementById('board'); b.innerHTML = '';
            board = Array(SIZE).fill(null).map(() => Array(SIZE).fill(null));
            for (let r = 0; r < SIZE; r++)
            {
                for (let c = 0; c < SIZE; c++)
                {
                    let d = document.createElement('div');
                    d.className = 'cell';
                    d.onclick = () => handleTap(r, c);
                    b.appendChild(d);
                }
            }
        }

        async function prepareTurn()
        {
            if (isOver) return;
            isProcessing = true;
            updateTurnUI();

            // å¦‚æœæ˜¯ AI æ¨¡å¼ï¼Œæˆ– æ˜¯æˆ‘çš„å›åˆ
            // é€™è£¡é‚è¼¯ï¼šå¦‚æœæ˜¯ PVPï¼Œè¼ªåˆ°æˆ‘æ™‚æˆ‘ç”¢ç”Ÿéš¨æ©Ÿæ‰‹ç‰Œä¸¦å‚³çµ¦å°æ–¹
            if (turn === myRole || isAI)
            {
                let r = Math.random() * 100;
                if (r < 15) hand = 'MAGE'; else if (r < 35) hand = 'KNIGHT'; else hand = 'LORD';
                handDir = hand === 'KNIGHT' ? DIRS[Math.floor(Math.random() * DIRS.length)] : null;

                if (conn && conn.open)
                {
                    conn.send({ type: 'SYNC_CARD', hand, handDir });
                }
            }
            updateCardUI();
            isProcessing = false;

            // AI æ€è€ƒ
            if (isAI && turn === 'AI') setTimeout(aiLogic, 600);
        }

        function updateTurnUI()
        {
            const indicator = document.getElementById('turn-indicator');
            const boardEl = document.getElementById('board');
            const isMyTurn = (turn === myRole);

            let turnText = "";
            if (isAI)
            {
                turnText = (turn === 'PLAYER') ? "â— ä½ çš„å›åˆ" : "â—‹ AI æ€è€ƒä¸­...";
            } else
            {
                turnText = isMyTurn ? "â— ä½ çš„å›åˆ" : "â—‹ å°æ‰‹å›åˆ";
            }

            indicator.innerText = turnText;
            indicator.className = (turn === 'PLAYER' ? "turn-my" : "turn-opp");

            if (!isMyTurn) indicator.classList.add('turn-wait');

            if (isMyTurn) boardEl.classList.add('my-turn-glow');
            else boardEl.classList.remove('my-turn-glow');
        }

        function updateCardUI()
        {
            document.getElementById('res-icon').innerText = PIECE_DATA[hand].i;
            document.getElementById('res-dir').innerText = hand === 'MAGE' ? 'â‡ ğŸ§™â‡¢' : (handDir ? handDir.icon : '');
        }

        async function handleTap(r, c)
        {
            if (isOver || isProcessing || turn !== myRole || board[r][c]) return;

            if (conn && conn.open)
            {
                conn.send({ type: 'MOVE', r, c, hand, handDir });
            }
            await executeMove(r, c, myRole, hand, handDir);
        }

        async function executeMove(r, c, p, type, dir)
        {
            isProcessing = true;
            lastPos = { r, c };
            board[r][c] = { p, type, knightDir: dir, isConverted: false };
            render();
            await new Promise(res => setTimeout(res, 400));

            let triggered = true;
            while (triggered)
            {
                triggered = await checkAndTriggerSkills();
                if (triggered) { render(); await new Promise(res => setTimeout(res, 400)); }
            }

            if (checkWin(p)) { isOver = true; showWin(p); return; }

            turn = (p === 'PLAYER') ? 'AI' : 'PLAYER';
            prepareTurn();
        }

        // --- æŠ€èƒ½é‚è¼¯ (é¨å£«è¡é‹’ã€æ³•å¸«è½‰åŒ–) ---
        async function checkAndTriggerSkills()
        {
            for (let r = 0; r < SIZE; r++)
            {
                for (let c = 0; c < SIZE; c++)
                {
                    let pce = board[r][c];
                    if (!pce) continue;

                    if (pce.type === 'KNIGHT' && pce.knightDir)
                    {
                        let tr = r + pce.knightDir.dr, tc = c + pce.knightDir.dc;
                        // è¡æ’æ•µæ–¹
                        if (tr >= 0 && tr < SIZE && tc >= 0 && tc < SIZE && board[tr][tc] && board[tr][tc].p !== pce.p)
                        {
                            await popMsg("é¨å£«è¡é‹’ï¼");
                            board[tr][tc] = null; // æ®ºæ­»æ•µæ–¹
                            board[r][c] = null;   // é¨å£«çŠ§ç‰²
                            return true;
                        }
                    } else if (pce.type === 'MAGE')
                    {
                        let targets = [];
                        // å·¦å³å„ä¸€æ ¼
                        [[0, -1], [0, 1]].forEach(([dr, dc]) =>
                        {
                            let tr = r + dr, tc = c + dc;
                            if (tr >= 0 && tr < SIZE && tc >= 0 && tc < SIZE && board[tr][tc] && board[tr][tc].p !== pce.p) targets.push({ tr, tc });
                        });

                        if (targets.length > 0)
                        {
                            await popMsg("æ³•è¡“æ´—è…¦ï¼");
                            targets.forEach(t =>
                            {
                                board[t.tr][t.tc].p = pce.p;
                                board[t.tr][t.tc].isConverted = true;
                            });
                            board[r][c] = null; // æ³•å¸«æ¶ˆå¤±
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- AI é‚è¼¯ (ä¿ç•™åŸç‰ˆ) ---
        function aiLogic()
        {
            let bestScore = -Infinity, bestMoves = [];
            for (let r = 0; r < SIZE; r++)
            {
                for (let c = 0; c < SIZE; c++)
                {
                    if (board[r][c]) continue;
                    let score = 0;
                    if (hand === 'LORD')
                    {
                        score = evaluatePoint(r, c, 'AI') * 1.5 + evaluatePoint(r, c, 'PLAYER');
                        if (checkFive(r, c, 'AI')) score += 50000;
                        if (checkFive(r, c, 'PLAYER')) score += 20000;
                    } else if (hand === 'KNIGHT' && handDir)
                    {
                        let tr = r + handDir.dr, tc = c + handDir.dc;
                        if (tr >= 0 && tr < SIZE && tc >= 0 && tc < SIZE && board[tr][tc] && board[tr][tc].p === 'PLAYER') score = 1500;
                    } else if (hand === 'MAGE')
                    {
                        [[0, -1], [0, 1]].forEach(([dr, dc]) =>
                        {
                            let tr = r + dr, tc = c + dc;
                            if (tr >= 0 && tr < SIZE && tc >= 0 && tc < SIZE && board[tr][tc] && board[tr][tc].p === 'PLAYER') score += 1800;
                        });
                    }
                    score += Math.random() * 5;
                    if (score > bestScore) { bestScore = score; bestMoves = [{ r, c }]; }
                    else if (score === bestScore) { bestMoves.push({ r, c }); }
                }
            }
            let m = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            executeMove(m.r, m.c, 'AI', hand, handDir);
        }

        function evaluatePoint(r, c, p)
        {
            const dirs = [[1, 0], [0, 1], [1, 1], [1, -1]];
            let totalScore = 0;
            for (let [dr, dc] of dirs)
            {
                let count = 1, block = 0;
                [1, -1].forEach(sig =>
                {
                    for (let i = 1; i < 5; i++)
                    {
                        let nr = r + dr * i * sig, nc = c + dc * i * sig;
                        if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE)
                        {
                            if (board[nr][nc]?.p === p && board[nr][nc]?.type === 'LORD') count++;
                            else if (board[nr][nc]) { block++; break; } else break;
                        } else { block++; break; }
                    }
                });
                if (count >= 5) totalScore += 10000;
                else if (count === 4) totalScore += (block === 0 ? 5000 : 500);
                else if (count === 3) totalScore += (block === 0 ? 400 : 50);
            }
            return totalScore;
        }

        // --- å‹è² åˆ¤å®š ---
        function checkWin(p)
        {
            for (let r = 0; r < SIZE; r++)
            {
                for (let c = 0; c < SIZE; c++)
                {
                    if (board[r][c]?.p === p && board[r][c]?.type === 'LORD' && checkFive(r, c, p)) return true;
                }
            }
            return false;
        }

        function checkFive(r, c, p)
        {
            return [[1, 0], [0, 1], [1, 1], [1, -1]].some(([dr, dc]) =>
            {
                let count = 1;
                [1, -1].forEach(sig =>
                {
                    for (let i = 1; i < 5; i++)
                    {
                        let nr = r + dr * i * sig, nc = c + dc * i * sig;
                        if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nr][nc]?.p === p && board[nr][nc]?.type === 'LORD') count++; else break;
                    }
                });
                return count >= 5;
            });
        }

        // --- æ¸²æŸ“èˆ‡å·¥å…· ---
        function render()
        {
            const cells = document.querySelectorAll('.cell');
            for (let r = 0; r < SIZE; r++)
            {
                for (let c = 0; c < SIZE; c++)
                {
                    let cell = cells[r * SIZE + c]; cell.innerHTML = '';
                    let d = board[r][c];
                    if (d)
                    {
                        let p = document.createElement('div');
                        p.className = `piece ${PIECE_DATA[d.type].class} ${d.p.toLowerCase()} ${d.isConverted ? 'converted' : ''}`;
                        if (lastPos && lastPos.r === r && lastPos.c === c) p.classList.add('last-move');
                        p.innerHTML = `<span>${PIECE_DATA[d.type].i}</span>` + (d.knightDir ? `<span class="dir-hint">${d.knightDir.icon}</span>` : '');
                        cell.appendChild(p);
                    }
                }
            }
        }

        async function popMsg(t)
        {
            const m = document.getElementById('msg-pop');
            m.innerText = t; m.style.opacity = 1;
            await new Promise(res => setTimeout(() => { m.style.opacity = 0; res(); }, 800));
        }

        function showWin(p)
        {
            const overlay = document.getElementById('win-overlay');
            const text = document.getElementById('win-text');
            // é€™è£¡çš„é‚è¼¯ï¼šå¦‚æœè´å®¶ p ç­‰æ–¼ myRoleï¼Œé¡¯ç¤ºå‹åˆ©
            // ä½†å¦‚æœæ˜¯åœ¨ AI æ¨¡å¼ä¸‹ï¼Œp='PLAYER' å°±è´äº†
            const iWon = (p === myRole) || (isAI && p === 'PLAYER');

            text.innerText = iWon ? "ğŸ† é ˜ä¸»ç²å¾—å‹åˆ©ï¼" : "ğŸ’€ é ˜åœ°å¤±å®ˆäº†...";
            text.style.color = iWon ? "#27ae60" : "#ff4d4d";
            overlay.classList.add('show');
        }

        function copyID()
        {
            const id = document.getElementById('my-id').innerText;
            if (id && id !== 'ç”Ÿæˆä¸­...')
            {
                navigator.clipboard.writeText(id).then(() => popMsg("ä»£ç¢¼å·²è¤‡è£½"));
            }
        }
    </script>
</body>

</html>